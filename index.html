<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Filters</title>
    <link rel="stylesheet" href="style.css">
</head>

<div class="header">
    <!-- Use the buttons to create multiple pages later if required -->
    <button class="button">Filters</button>
    <button class="button">Complex Filters</button>
</div>

<!--create canvas, and add interface related stuff like sliders etc -->
<canvas id="c"></canvas>
<div id="imgs">
    <p>Drag and drop an image into the box</p>
    <div id="image_drop_area"></div>
</div>
<div id="sizes">
    <div class="rangeslider">
        <input type="range" min="1" max="20" value="3" id="kernelSize" step="2" >
        <label for="kernelSize">Kernel Size</label><br>
    </div>
    <br><br><br><br><br><br><br>
    <div class="rangeslider">
        <input type="range" min="0" max="180" value="0" id="angleSlider" step="2" >
        <label for="kernelSize">Angle for Motion Blur</label><br>
    </div>

</div>
<div id="slides">
    <input type="radio" name="blur_rb" id="blur0"  value="0" checked="checked">
    <label for="blur0">No Blur</label><br><br>
    <input type="radio" name="blur_rb" id="blur1"  value="1">
    <label for="blur1">Box Blur</label><br><br>
    <input type="radio" name="blur_rb" id="blur2"  value="2">
    <label for="blur2">Gaussian Blur</label><br><br>
    <input type="radio" name="blur_rb" id="blur3"  value="3">
    <label for="blur3">Dilate</label><br><br>
    <input type="radio" name="blur_rb" id="blur6"  value="4">
    <label for="blur6">Motion Blur</label><br><br>

</div>


<!-- vertex shader -->
<script  id="vertex-shader-2d" type="x-shader/x-vertex">#version 300 es

// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
in vec2 a_position;
in vec2 a_texCoord;

// Used to pass in the resolution of the canvas
uniform vec2 u_resolution;

// Used to pass the texture coordinates to the fragment shader
out vec2 v_texCoord;

// all shaders will have a main function
//Following is almost similar to the webglfundamentals tutorial
void main() {

  // convert the position from pixels to 0.0 to 1.0
  vec2 zeroToOne = a_position / u_resolution;

  // convert from 0->1 to 0->2
  vec2 zeroToTwo = zeroToOne * 2.0;

  // convert from 0->2 to -1->+1 (clipspace)
  vec2 clipSpace = zeroToTwo - 1.0;

  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

  // pass the texCoord to the fragment shader
  // The GPU will interpolate this value between points.
  v_texCoord = a_texCoord;
}
</script>


<!-- fragment shader -->
<script  id="fragment-shader-2d" type="x-shader/x-fragment" >#version 300 es

// fragment shaders don't have a default precision so we need
// to pick one. highp is a good default. It means "high precision"
precision highp float;

// our texture
uniform sampler2D u_image;

// the convolution kernel data
uniform float u_kernel[400];
uniform float u_kernelWeight;
uniform int u_kernelSize;
uniform int u_kernelSelf;
uniform int type;

// the texCoords passed in from the vertex shader.
in vec2 v_texCoord;

// we need to declare an output for the fragment shader
out vec4 outColor;

void main() {
  vec2 onePixel = vec2(1) / vec2(textureSize(u_image, 0));

  vec4 colorSum = vec4(0.0);


  //based on what the kernel type is, apply the kernel to get result for the pixel
  if (type!=3){
        for(int i=-(u_kernelSize - 1)/2; i<=(u_kernelSize - 1)/2; i++)
          {
            for(int j=-(u_kernelSize - 1)/2; j<=(u_kernelSize - 1)/2; j++)
            {
                colorSum = colorSum + texture(u_image, v_texCoord + onePixel * vec2(i,j)) * u_kernel[(j+(u_kernelSize - 1)/2) + (i+ (u_kernelSize - 1)/2 )*u_kernelSize];
            }
          }
          colorSum = vec4((colorSum).rgb/u_kernelWeight, 1);

  }
  else if(type==3){
        float maxW = -1., maxR = -1., maxG = -1., maxB = -1.;

        for(int i=-(u_kernelSize - 1)/2; i<=(u_kernelSize - 1)/2; i++)
          {
            for(int j=-(u_kernelSize - 1)/2; j<=(u_kernelSize - 1)/2; j++) {

                  vec4 tmp_clr = texture(u_image, v_texCoord + onePixel * vec2(i,j)) * u_kernel[(j+(u_kernelSize - 1)/2) + (i+ (u_kernelSize - 1)/2 )*u_kernelSize];
                  if (tmp_clr.r > maxR)
                    maxR = tmp_clr.r;
                  if (tmp_clr.g > maxG)
                    maxG = tmp_clr.g;
                  if (tmp_clr.b > maxB)
                    maxB = tmp_clr.b;
                  if (u_kernel[(j+(u_kernelSize - 1)/2) + (i+ (u_kernelSize - 1)/2 )*u_kernelSize] > maxW)
                    maxW = u_kernel[(j+(u_kernelSize - 1)/2) + (i+ (u_kernelSize - 1)/2 )*u_kernelSize];
             }
            }

         colorSum = vec4(maxR/maxW, maxG/maxW, maxB/maxW, 1);
  }


  outColor = vec4((colorSum).rgb, 1);
}

</script>
<!-- using some webgl utilities as follows -->
<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webgl2fundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
<script src="script.js"></script>
<body>

</body>