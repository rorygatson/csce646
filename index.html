<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Filters</title>
    <link rel="stylesheet" href="style.css">
</head>

<div class="header">
    <!-- Use the buttons to create multiple pages later if required -->
    <header>Curve Integral Convolution with Implicit Functions</header>
</div>

<!--create canvas, and add interface related stuff like sliders etc -->
<canvas id="c"></canvas>
<div id="imgs">
    <p>Drag and drop an image into the box</p>
    <div id="image_drop_area"></div>
</div>

<div id="sizes">
  <div class="rangeslider">
    <input type="range" min="1" max="19" value="3" id="kernelSlider" step="2" >
    <label for="kernelSize">Blur Kernel Size</label><br>
  </div>
  <br>
  <div class="rangeslider">
    <input type="range" min="1" max="20" value="1" id="widthSlider" step="1" >
    <label for="functionWidth">Function Width</label><br>
  </div>
  <br>
  <div class="rangeslider">
    <input type="range" min="1" max="200" value="50" id="xSlider" step="1" >
    <label for="xOrigin">Center X Coord.</label><br>
  </div>
  <br>
  <div class="rangeslider">
    <input type="range" min="1" max="200" value="50" id="ySlider" step="1" >
    <label for="yOrigin">Extra Modifier</label><br>
  </div>
  <br>
</div>

<div id="slides">
    <input type="radio" name="hist_rb" id="hist0"  value="0" checked="checked">
    <label for="blur0">Original</label><br><br>
    <input type="radio" name="hist_rb" id="hist3"  value="3">
    <label for="blur3">Function 3 - Circle</label><br><br>
    <input type="radio" name="hist_rb" id="hist4"  value="4">
    <label for="blur4">Function 4 - Sinusoid Fixed</label><br><br>
    <input type="radio" name="hist_rb" id="hist5"  value="5">
    <label for="blur5">Function 5 - Linear</label><br><br>
    <input type="radio" name="hist_rb" id="hist6"  value="6">
    <label for="blur6">Function 6 - Pentagon</label><br><br>
</div>


<!-- vertex shader -->
<script  id="vertex-shader-2d" type="x-shader/x-vertex">#version 300 es

// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
in vec2 a_position;
in vec2 a_texCoord;

// Used to pass in the resolution of the canvas
uniform vec2 u_resolution;

// Used to pass the texture coordinates to the fragment shader
out vec2 v_texCoord;

// all shaders will have a main function
//Following is almost similar to the webglfundamentals tutorial
void main() {

  // convert the position from pixels to 0.0 to 1.0
  vec2 zeroToOne = a_position / u_resolution;

  // convert from 0->1 to 0->2
  vec2 zeroToTwo = zeroToOne * 2.0;

  // convert from 0->2 to -1->+1 (clipspace)
  vec2 clipSpace = zeroToTwo - 1.0;

  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

  // pass the texCoord to the fragment shader
  // The GPU will interpolate this value between points.
  v_texCoord = a_texCoord;
}
</script>


<!-- fragment shader -->
<script  id="fragment-shader-2d" type="x-shader/x-fragment" >#version 300 es

// fragment shaders don't have a default precision so we need
// to pick one. highp is a good default. It means "high precision"
#define M_PI 3.1415926535897932384626433832795
precision highp float;

// our texture
uniform sampler2D u_image;

// the convolution kernel data
uniform float u_kernel[400];
uniform float u_kernelWeight;
uniform int u_kernelSize;
uniform int u_kernelSelf;
uniform int type;

uniform float u_width;
uniform float u_xorigin;
uniform float u_yorigin;

// the texCoords passed in from the vertex shader.
in vec2 v_texCoord;

// we need to declare an output for the fragment shader
out vec4 outColor;

void main() {
  vec2 onePixel = vec2(1) / vec2(textureSize(u_image, 0));
  vec4 colorSum = vec4(0.0);

  vec4 tmp_clr = texture(u_image, v_texCoord);

  // Shader based on radio button selection
  if (type == 3) { // Circle
    int num_overlap = 0;
    vec2 pixelLoc = v_texCoord / onePixel;
    float radius = sqrt( pow((v_texCoord.x - u_xorigin), 2.0) + pow((v_texCoord.y - u_yorigin), 2.0));
    
    // Loop through each pixel in box blur region
    for(int i=-(u_kernelSize - 1)/2; i<=(u_kernelSize - 1)/2; i++) {
      for(int j=-(u_kernelSize - 1)/2; j<=(u_kernelSize - 1)/2; j++) {

        // Get coordinate in box blur
        vec2 new_coord = v_texCoord + onePixel * vec2(i,j);

        // Calculate distance value for whether new point falls inside point specific kernel
        float d_query = sqrt( pow((new_coord.x - u_xorigin), 2.0) + pow((new_coord.y - u_yorigin), 2.0));
        
        // If new point 
        if ( abs(d_query - radius) < u_width ) {
          colorSum = colorSum + texture(u_image, v_texCoord + onePixel * vec2(i,j)) * u_kernel[(j+(u_kernelSize - 1)/2) + (i+ (u_kernelSize - 1)/2 )*u_kernelSize];
          num_overlap += 1;
        }

      }
    }
    colorSum /= float(num_overlap) / (float(u_kernelSize) * float(u_kernelSize));

  }
  else if (type == 4) { // Sinusoid fixed
    // y = 0.1 * sin( 20 * x - u_xorigin ) + displacement
    int num_overlap = 0;
    float displacement = v_texCoord.y - (0.1 * sin( 20.0 * v_texCoord.x - u_xorigin));

    // Loop through each pixel in box blur region
    for(int i=-(u_kernelSize - 1)/2; i<=(u_kernelSize - 1)/2; i++) {
      for(int j=-(u_kernelSize - 1)/2; j<=(u_kernelSize - 1)/2; j++) {
        // If within approximate d (width) of sin function, add to box blur
        vec2 new_coord = v_texCoord + onePixel * vec2(i,j);
        // Using simpler vertical distance to filter width
        float d = abs(new_coord.y - (0.1 * sin( 20.0 * new_coord.x - u_xorigin ) + displacement));
        if ( d < u_width ) {
          colorSum = colorSum + texture(u_image, v_texCoord + onePixel * vec2(i,j)) * u_kernel[(j+(u_kernelSize - 1)/2) + (i+ (u_kernelSize - 1)/2 )*u_kernelSize];
          num_overlap += 1;
        }

      }
    }
    colorSum /= float(num_overlap) / (float(u_kernelSize) * float(u_kernelSize));
  }
  else if (type == 5) { // Linear
    // y = (input slope)x + displacement
    float slope = (u_yorigin - 1.0) * 5.0 + 0.001; // Slope based on extra modifier still named u_yorigin i.e. TODO: change name
    int num_overlap = 0;
    float displacement = v_texCoord.y - (slope * v_texCoord.x);

    // Loop through each pixel in box blur region
    for(int i=-(u_kernelSize - 1)/2; i<=(u_kernelSize - 1)/2; i++) {
      for(int j=-(u_kernelSize - 1)/2; j<=(u_kernelSize - 1)/2; j++) {
        // If within approximate d (width) of sin function, add to box blur
        vec2 new_coord = v_texCoord + onePixel * vec2(i,j);
        // Calculate distance between point and line
        float i_slope = 1.0 / slope;
        float x_inter = (new_coord.y - i_slope * new_coord.x - displacement) / (slope - i_slope);
        float y_inter = slope * x_inter + displacement;
        float d = sqrt( pow((new_coord.x - x_inter), 2.0) + pow((new_coord.y - y_inter), 2.0) );
        // If distance is less than function width add to blur
        if ( d < u_width ) {
          colorSum = colorSum + texture(u_image, v_texCoord + onePixel * vec2(i,j)) * u_kernel[(j+(u_kernelSize - 1)/2) + (i+ (u_kernelSize - 1)/2 )*u_kernelSize];
          num_overlap += 1;
        }
      }
    }
    colorSum /= float(num_overlap) / (float(u_kernelSize) * float(u_kernelSize));
  }
  else if (type == 6) { // Pentagon
    // y = (input slope)x + displacement
    int num_overlap = 0;
    float offset = 0.0;
    int num_sides = 5;
    float adj_dot = (v_texCoord.x - u_xorigin) / sqrt( pow((v_texCoord.x - u_xorigin), 2.0) + pow((v_texCoord.y - u_yorigin), 2.0));
    float angle = acos(adj_dot); // Calculate angle
    if (v_texCoord.y < u_yorigin) {
      angle = 2.0 * M_PI - angle;
    }
    float increment = 2.0 * M_PI / float(num_sides);
    float slope = -1.0 / tan((floor(angle / increment) + 0.01 ) * increment + M_PI / float(num_sides)); // add 0.01 as rudimentary fix for zero case
    float displacement = v_texCoord.y - (slope * v_texCoord.x);

    // Loop through each pixel in box blur region
    for(int i=-(u_kernelSize - 1)/2; i<=(u_kernelSize - 1)/2; i++) {
      for(int j=-(u_kernelSize - 1)/2; j<=(u_kernelSize - 1)/2; j++) {
        // If within approximate d (width) of sin function, add to box blur
        vec2 new_coord = v_texCoord + onePixel * vec2(i,j);
        // Calculate distance between point and line
        float i_slope = 1.0 / (slope); // rudimentary fix for slope 0
        float x_inter = (new_coord.y - i_slope * new_coord.x - displacement) / (slope - i_slope);
        float y_inter = slope * x_inter + displacement;
        float d = sqrt( pow((new_coord.x - x_inter), 2.0) + pow((new_coord.y - y_inter), 2.0) );
        
        // If distance is less than function width add to blur
        if ( d < u_width ) {
          colorSum = colorSum + texture(u_image, v_texCoord + onePixel * vec2(i,j)) * u_kernel[(j+(u_kernelSize - 1)/2) + (i+ (u_kernelSize - 1)/2 )*u_kernelSize];
          num_overlap += 1;
        }
      }
    }
    colorSum /= float(num_overlap) / (float(u_kernelSize) * float(u_kernelSize));
  }
  else { // Original
    colorSum = tmp_clr;
  }

  outColor = colorSum;
}

</script>
<!-- using some webgl utilities as follows -->
<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webgl2fundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
<script src="script.js"></script>
<body>

</body>