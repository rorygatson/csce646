<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Filters</title>
    <link rel="stylesheet" href="style.css">
</head>

<div class="header">
    <!-- Use the buttons to create multiple pages later if required -->
    <header>Project 1</header>
</div>

<!--create canvas, and add interface related stuff like sliders etc -->
<canvas id="c"></canvas>
<div id="imgs">
    <p>Drag and drop an image into the box</p>
    <div id="image_drop_area"></div>
</div>

<div id="sizes">
  <div class="rangeslider">
    <input type="range" min="1" max="19" value="3" id="kernelSlider" step="2" >
    <label for="kernelSize">Blur Kernel Size</label><br>
  </div>
  <br>
  <div class="rangeslider">
    <input type="range" min="1" max="200" value="1" id="widthSlider" step="1" >
    <label for="functionWidth">Function Width</label><br>
  </div>
  <br>
  <div class="rangeslider">
    <input type="range" min="1" max="100" value="1" id="xSlider" step="1" >
    <label for="xOrigin">Center X Coord.</label><br>
  </div>
  <br>
  <div class="rangeslider">
    <input type="range" min="1" max="100" value="1" id="ySlider" step="1" >
    <label for="yOrigin">Center Y Coord.</label><br>
  </div>
  <br>
</div>

<div id="slides">
    <input type="radio" name="hist_rb" id="hist0"  value="0" checked="checked">
    <label for="blur0">Original</label><br><br>
    <input type="radio" name="hist_rb" id="hist1"  value="1">
    <label for="blur1">Function 1 - Horizontal</label><br><br>
    <input type="radio" name="hist_rb" id="hist2"  value="2">
    <label for="blur2">Function 2 - Sinusoid</label><br><br>
</div>


<!-- vertex shader -->
<script  id="vertex-shader-2d" type="x-shader/x-vertex">#version 300 es

// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
in vec2 a_position;
in vec2 a_texCoord;

// Used to pass in the resolution of the canvas
uniform vec2 u_resolution;

// Used to pass the texture coordinates to the fragment shader
out vec2 v_texCoord;

// all shaders will have a main function
//Following is almost similar to the webglfundamentals tutorial
void main() {

  // convert the position from pixels to 0.0 to 1.0
  vec2 zeroToOne = a_position / u_resolution;

  // convert from 0->1 to 0->2
  vec2 zeroToTwo = zeroToOne * 2.0;

  // convert from 0->2 to -1->+1 (clipspace)
  vec2 clipSpace = zeroToTwo - 1.0;

  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

  // pass the texCoord to the fragment shader
  // The GPU will interpolate this value between points.
  v_texCoord = a_texCoord;
}
</script>


<!-- fragment shader -->
<script  id="fragment-shader-2d" type="x-shader/x-fragment" >#version 300 es

// fragment shaders don't have a default precision so we need
// to pick one. highp is a good default. It means "high precision"
precision highp float;

// our texture
uniform sampler2D u_image;

// the convolution kernel data
uniform float u_kernel[400];
uniform float u_kernelWeight;
uniform int u_kernelSize;
uniform int u_kernelSelf;
uniform int type;

uniform float u_width;
uniform float u_xorigin;
uniform float u_yorigin;

// the texCoords passed in from the vertex shader.
in vec2 v_texCoord;

// we need to declare an output for the fragment shader
out vec4 outColor;

void main() {
  vec2 onePixel = vec2(1) / vec2(textureSize(u_image, 0));
  vec4 colorSum = vec4(0.0);

  vec4 tmp_clr = texture(u_image, v_texCoord);

  // Shader based on radio button selection
  if (type == 1) { // Horizontal
    // Box blur loop
    int num_overlap = 0;
    for(int i=-(u_kernelSize - 1)/2; i<=(u_kernelSize - 1)/2; i++) {
      for(int j=-(u_kernelSize - 1)/2; j<=(u_kernelSize - 1)/2; j++) {

        // If on same horizontal line, add pixel color to blox blur
        vec2 new_coord = v_texCoord + onePixel * vec2(i, j);
        if (new_coord.y == v_texCoord.y) {
          colorSum = colorSum + texture(u_image, v_texCoord + onePixel * vec2(i,j)) * u_kernel[(j+(u_kernelSize - 1)/2) + (i+ (u_kernelSize - 1)/2 )*u_kernelSize];
          num_overlap += 1;
        }

      }
    }
    colorSum /= float(num_overlap) / (float(u_kernelSize) * float(u_kernelSize));
    colorSum = vec4((colorSum).rgb, 1);
  }
  else if (type == 2) { // Sinusoid
    // y = 50 * sin( x / 40 ) + 200
    // y' = 5 * cos(x / 40) / 4
    // http://www.imajeenyus.com/mathematics/20121112_distance_estimates/point_to_function.pdf
    // Easy to do because both function and derivative can be hardcoded in shader
    
    // Box blur loop
    int num_overlap = 0;
    vec2 pixelLoc = v_texCoord / onePixel;
    float curr_d = abs(v_texCoord.y - (0.1 * sin( 20.0 * v_texCoord.x ) + 0.5));
    if (curr_d < u_width / 200.0) {
      for(int i=-(u_kernelSize - 1)/2; i<=(u_kernelSize - 1)/2; i++) {
        for(int j=-(u_kernelSize - 1)/2; j<=(u_kernelSize - 1)/2; j++) {

          // If within approximate d (width) of sin function, add to box blur
          vec2 new_coord = v_texCoord + onePixel * vec2(i,j);

          // First attempt  using approximate distance from distance
          //float tan_y = sin( pixelLoc.x ) + 200.0 ;
          //float tan_slope = cos( pixelLoc.x );
          //float tan_b = tan_y - tan_slope * float( pixelLoc.x ); // b from y=mx+b
          //float d = abs(float(new_coord.y) - tan_slope * float(new_coord.x) - tan_b) / sqrt(pow(tan_slope, 2.0) + 1.0);
          
          // Using simpler vertical distance
          float d = abs(new_coord.y - (0.1 * sin( 20.0 * new_coord.x ) + 0.5));
          
          if ( d < u_width / 200.0 ) {
            colorSum = colorSum + texture(u_image, v_texCoord + onePixel * vec2(i,j)) * u_kernel[(j+(u_kernelSize - 1)/2) + (i+ (u_kernelSize - 1)/2 )*u_kernelSize];
            num_overlap += 1;
          }

        }
      }
      colorSum /= float(num_overlap) / (float(u_kernelSize) * float(u_kernelSize));
    }
    else {
      colorSum = tmp_clr;
    }
    colorSum = vec4((colorSum).rgb, 1);
  }
  else { // Original
    colorSum = tmp_clr;
  }

  outColor = colorSum;
}

</script>
<!-- using some webgl utilities as follows -->
<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webgl2fundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
<script src="script.js"></script>
<body>

</body>