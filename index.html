<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Filters</title>
    <link rel="stylesheet" href="style.css">
</head>

<div class="header">
    <!-- Use the buttons to create multiple pages later if required -->
    <header>Project 1</header>
</div>

<!--create canvas, and add interface related stuff like sliders etc -->
<canvas id="c"></canvas>
<div id="imgs">
    <p>Drag and drop an image into the box</p>
    <div id="image_drop_area"></div>
</div>

<div id="sizes">
  <div class="rangeslider">
    <input type="range" min="1" max="4" value="1" id="mapSlider" step="1" >
    <label for="mapSize">Threshold Map Size</label><br>
  </div>
  <br>
  <div class="rangeslider">
    <input type="range" min="5" max="100" value="50" id="dotSlider" step="5" >
    <label for="dotSize">Max Dot Size</label><br>
  </div>
  <br>
  <div class="rangeslider">
    <input type="range" min="4" max="16" value="8" id="dotNumSlider" step="2" >
    <label for="dotNum">Dot Spread</label><br>
  </div>
</div>

<div id="slides">
    <input type="radio" name="hist_rb" id="hist0"  value="0" checked="checked">
    <label for="blur0">Original</label><br><br>
    <input type="radio" name="hist_rb" id="hist1"  value="1">
    <label for="blur1">Ordered Dithering</label><br><br>
    <input type="radio" name="hist_rb" id="hist2"  value="2">
    <label for="blur2">Halftone</label><br><br>
</div>


<!-- vertex shader -->
<script  id="vertex-shader-2d" type="x-shader/x-vertex">#version 300 es

// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
in vec2 a_position;
in vec2 a_texCoord;

// Used to pass in the resolution of the canvas
uniform vec2 u_resolution;

// Used to pass the texture coordinates to the fragment shader
out vec2 v_texCoord;

// all shaders will have a main function
//Following is almost similar to the webglfundamentals tutorial
void main() {

  // convert the position from pixels to 0.0 to 1.0
  vec2 zeroToOne = a_position / u_resolution;

  // convert from 0->1 to 0->2
  vec2 zeroToTwo = zeroToOne * 2.0;

  // convert from 0->2 to -1->+1 (clipspace)
  vec2 clipSpace = zeroToTwo - 1.0;

  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

  // pass the texCoord to the fragment shader
  // The GPU will interpolate this value between points.
  v_texCoord = a_texCoord;
}
</script>


<!-- fragment shader -->
<script  id="fragment-shader-2d" type="x-shader/x-fragment" >#version 300 es

// fragment shaders don't have a default precision so we need
// to pick one. highp is a good default. It means "high precision"
precision highp float;

// our texture
uniform sampler2D u_image;

// the convolution kernel data
uniform float u_kernel[400];
uniform float u_kernelWeight;
uniform int u_kernelSize;
uniform int u_kernelSelf;
uniform int type;

uniform int u_dotSize;
uniform int u_dotNum;

// the texCoords passed in from the vertex shader.
in vec2 v_texCoord;

// we need to declare an output for the fragment shader
out vec4 outColor;

void main() {
  vec2 onePixel = vec2(1) / vec2(textureSize(u_image, 0));
  vec4 colorSum = vec4(0.0);

  vec2 pixelLoc = v_texCoord / onePixel;

  vec4 tmp_clr = texture(u_image, v_texCoord);

  // Get a greyscale value for image
  //float greyValue = (tmp_clr.r + tmp_clr.g + tmp_clr.b) / 3.0;
  float greyValue = 0.3 * tmp_clr.r + 0.6 * tmp_clr.g + 0.1 * tmp_clr.b;

  if (type == 1) {
    float filterValue = u_kernel[(int(pixelLoc.y) % u_kernelSize) * u_kernelSize + 
                                 (int(pixelLoc.x) % u_kernelSize)];

    // Initialize greyscale values
    float final_r = greyValue;
    float final_g = greyValue;
    float final_b = greyValue;

    // Filter Pass
    if (greyValue < filterValue) {
      final_r = 0.0;
      final_g = 0.0;
      final_b = 0.0;
    }
    else {
      final_r = 1.0;
      final_g = 1.0;
      final_b = 1.0;
    }
    outColor = vec4(final_r, final_g, final_b, 1);
  }
  else if (type == 2) {
    
    // For each pixel in given square
    int x_edge = int(pixelLoc.x) % u_dotSize;
    int y_edge = int(pixelLoc.y) % u_dotSize;
    
    // Find average grey value of region
    vec4 color_i = vec4(0.0);
    float greySum = 0.0;
    for(int i = -y_edge; i <= u_dotSize-1-y_edge; i++) {
      for(int j= -x_edge; j <= u_dotSize-1-x_edge; j++) {
          color_i = texture(u_image, v_texCoord + onePixel * vec2(j, i));
          greySum += 0.3 * color_i.r + 0.6 * color_i.g + 0.1 + color_i.b;
      }
    }
    float avgGrey = greySum / (float(u_dotSize) * float(u_dotSize));

    // Determine what size dot for region
    float dotFrac = 1.0 / float(u_dotNum);
    int i_pin = int(avgGrey * 1000.0) / int(dotFrac * 1000.0);
    float f_pin = dotFrac * float(i_pin);

    float f_dotSize = float(u_dotSize);
    float distCenter = sqrt(pow((pixelLoc.x - float(x_edge) + f_dotSize / 2.0) - pixelLoc.x, 2.0) 
                            + pow((pixelLoc.y - float(y_edge) + f_dotSize / 2.0) - pixelLoc.y, 2.0));
    
    // Initialize greyscale values
    float final_r = avgGrey;
    float final_g = avgGrey;
    float final_b = avgGrey;

    if (distCenter / (f_dotSize / 2.0) < (1.0 - f_pin)) {
      final_r = 0.0;
      final_g = 0.0;
      final_b = 0.0;
    }
    else {
      final_r = 1.0;
      final_g = 1.0;
      final_b = 1.0;
    }
    outColor = vec4(final_r, final_g, final_b, 1);

  }
  else {
    outColor = tmp_clr;
  }




}

</script>
<!-- using some webgl utilities as follows -->
<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webgl2fundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
<script src="script.js"></script>
<body>

</body>